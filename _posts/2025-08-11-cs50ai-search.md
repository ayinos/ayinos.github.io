---
title: CS50AI Search
date: 2025-08-11 02:00:00 +/-TTTT
categories: [AI, CS50AI]
tags: [ai,cs50ai,search,cs50,course]     # TAG names should always be lowercase
---

# CS50AI Search

Notes from the [Harvard CS50AI](https://pll.harvard.edu/course/cs50s-introduction-artificial-intelligence-python) online course.

## Intro
- We would like the AI to be able to search for solutions to some kind a problem.

## Examples of Search Problems
- 15 puzzle game
- tic tac toe game
- a maze
- google maps

## Terminologies
| Term                 | Description                                                                                                                                                                                                                    |
|----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Agent**            | Entity that perceives and acts in an environment.<br>**Example:** Car in Google Maps; Person playing the game in 15 puzzle or tic-tac-toe.                                                                                     |
| **State**            | Configuration of the environment.<br>**Example:** Configuration of tiles in 15 puzzle.                                                                                                                                         |
| **Initial State**    | State where the agent begins.<br>**Example:** Start position in Google Maps; scrambled starting layout in 15 puzzle.                                                                                                           |
| **Actions**          | Choices that can be made in any given state; returns all valid actions for a given state.<br>**Function:** actions(s) → set of valid actions in state `s`.<br>**Example:** In 15 puzzle, move tile left, right, up, or down.   |
| **Transition Model** | Describes what state results from performing a given action in a given state.<br>**Function:** result(s, a) → new state after performing action `a` in state `s`.                                                              |
| **State Space**      | Set of all states reachable from the initial state by any sequence of actions.                                                                                                                                                 |
| **Goal Test**        | Method to determine whether a state is a goal state. Some problems may have one goal; others may have multiple.<br>**Example:** In 15 puzzle, numbers in ascending order; in Google Maps, current location equals destination. |
| **Path Cost**        | Numerical cost associated with a given path; applies only to some problems.<br>**Example:** In Google Maps, total distance or time. But does not apply to 15 puzzle, since each move has the same cost.                        |
| **Solution**         | Sequence of actions that will take the agent from the initial state to the goal state.                                                                                                                                         |
| **Optimal Solution** | A solution with the lowest path cost among all solutions.                                                                                                                                                                      |

## Search Problems
<iframe src="/assets/markmaps/cs50ai-01search-03.html" width="100%" height="600" style="border:none;"></iframe>

## Representing search.
![cs50ai-01search-02-graphwithpathcosts.png](/assets/images/cs50ai-01search-02-graphwithpathcosts.png)

## Node
a data structure that keeps track of
- a state
- a parent (node that generated this node)
- an action (action applied to parent to get node)
- a path cost (from initial state to node)

## Approach
- Start with a frontier that contains the initial state.
- Start with an empty explored set. (Remembering explored nodes is needed so that we do not end up in a loop visiting 
the same states again in cases where there is a path/action leading from A->B but also from B->A)
- Repeat:
  - If the frontier is empty, then no solution.
  - Remove a node from the frontier.
  - If node contains goal state, return the solution.
  - Add the node to the explored set.
  - Expand node, add resulting nodes to the frontier if they aren't already in the frontier or the explored set.

